# 객체와 자료구조

### 자료 추상화

"객체"와 "자료구조"는 다르다. 객체는 비공개 변수를 가지며 조회를 위해 사용하는 비공개 메서드를 노출하는 반면에, 자료구조는 공개변수를 가지고 구체적이다. 객체는 추상적인 개념을 가지며 자료구조는 단순히 자료를 표현하는데 그친다.

### 자료/객체 비대칭

* 절차지향적인 코드로 객체를 구성하면, 새로운 함수를 추가하기는 편하지만 새로운 자료구조를 추가할 경우 함수를 뜯어고쳐야 하는 단점이 있다.
* 객체지향적인 코드로 객체를 구성하면, 새로운 자료구조를 추가하기 쉽지만 새로운 함수를 추가할 경우 전체 객체를 뜯어고쳐야 하는 단점이 있다.
* 즉, 절차지향/객체지향은 각자의 장단점이 존재하고 새로운 자료구조가 필요할 경우, 객체지향적으로. 새로운 함수가 필요할 경우 절차지향적으로 유연하게 코드를 작성하는 것이 좋다.

### 디미터 법칙

모듈이 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙으로 임의의 클래스 C의 메서드 f가 다음 조건을 만족해야 한다.

- 클래스 C 의 인스턴스 변수에 저장된 객체의 메서드를 호출할수 있다.
- 인수로 넘어온 객체의 메서드를 호출할 수 있다.
- 내부에서 생성한 객체의 메서드를 호출할 수 있다.
- 클래스 C의 메서드를 호출할 수 있다.

클래스의 메서드를 정의할 때, 이러한 디미터 법칙을 고려해서 메서드가 조작하는 객체가 내부구조를 노출하는지 여부를 판단해야 한다. 이런 점을 명확히 고려하지 않으면, 자료구조와 객체가 혼합된 "잡종 구조" 를 만들 가능성이 있고 이는 불완전한 설계로 이어지게 된다.

만약, 메서드가 사용하는 객체가 디미터 법칙을 위반하고 있다면 어떻게 해당 법칙을 충족시킬 수 있을지 고민해봐야 한다. 객체가 뭘 하라고 해야지 속을 드러내게끔 구성해선 안된다. 만약 내부 구조를 세세하게 드러내서 그것들을 사용해야 한다면 그걸 객체 내부로 몰아넣고 외부 메서드로 사용하도록 하자.

### 자료 전달 객체

DTO(Data Transfer Object) 라고 불리는 이러한 형태는 공개변수만을 노출하는 자료구조인데, 조회/설정(getter/setter) 함수만 노출시키는 빈(Bean) 구조를 사용하거나 아니면 탐색함수까지 포함하는 활성 레코드라는 형태를 사용한다. 이걸 "객체" 로 착각하기 쉽지만, 단순히 비공개 변수를 읽거나/설정하거나/찾거나 하는 경우의 메서드만을 가지고 있기 때문에 "자료구조" 라는 사실을 기억하고 이곳에 비즈니스 로직을 넣어서는 안된다.